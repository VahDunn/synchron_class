**Задача - синхронизация данных между двумя БД с сохранением данных во второй**
Код в директории synchronizer.

Задача реализуется через соответствующий класс.
Что нам нужно:
Доступ к двум базам данных. Под доступом имеется в виду наличие непосредственно самих БД,
открытые порты к ним и данные для входа (пользователь/пароль) 
В моем случае это postgres версии 15. 
Предположим, что они реализованы через Docker - создано два контейнера на разных портах (5432 и 5434).
Строки для доступа к ним: 
source_db_url = "postgresql://postgres:pampampam@localhost:5432/postgres"
target_db_url = "postgresql://postgres:pumpumpum@localhost:5434/postgres"
В самом классе они захардкожены, но по-хорошему их нужно реализовывать через переменные окружения (.env).

То есть требуется создать файл .env, добавить в него соответствующие строки, а сам скрипт запускать с указанием 
переменных окружения (в PyCharm это делается через настройки запуска в правом верхнем углу).

Также требуется установка 

* SQLAlchemy

То есть ORM (object relational manager), через которую будет реализовываться перенос данных. 
ORM может быть и другая, например, Django ORM в случае работы с соответствующим фреймворком. 

Последнее, что нужно - названия таблиц в базах данных (предполагается, что они в обеих БД имеют одинаковые названия)


Для начала, именуем сам класс (он явно ни от чего не наследуется, поэтому можно без скобок).
Внутри пишем логику инициализации экземпляра класса, то есть

* def __init__(self, source_db_url: str, target_db_url: str):

Для работы нам потребуются описанные выше строки для доступа к БД, поэтому их мы принимаем в инициализирующий метод.
С их помощью создаем движки БД и присваиваем их полям, а также создаем два поля для метаданных о БД. 
В классе предполагается наличие трех основных методов. Первый из них: 

* def get_table_differences(self, table_name: str) -> Dict[str, List[Any]]:

Данный метод должен принимать название таблицы и сравнивать таблицы с этим названием
в указанных при инициализации экземпляра класса БД, возвращая различия в виде словаря.

Словарь может иметь следующую структуру: 

*        differences = {
*            'new_columns': [],
*            'modified_columns': [],
*            'removed_columns': []
*        }

Для чего это нужно? 
Для того, чтобы логика, которая синхронизирует две бд, не трогала таблицы, в которых столбцы
не соответствуют друг другу по названию или типу. Для подобных ситуаций требуется конкретная реализация
в зависимости от таблиц и их различий. 

Непосредственная реализация - вложенным циклом проходимся по колонкам таблиц, добавляем в соответствующий список в 
нашем словаре. 

Пример:

*        for col_name, source_col in source_columns.items():
*            if col_name not in target_columns:
*                differences['new_columns'].append(col_name)

Переходим ко второму методу: 

* def synchronize_table(self, table_name: str) -> None:

Этот метод должен принимать название таблицы и пытаться провести синхронизацию между базами данных. 
Последовательность действий: 

1. На основе имеющихся у нас движков и метаданных ищем в БД интересующие нас таблицы.
Пример: 

* source_table = Table(table_name, self.source_metadata, autoload_with=self.source_engine)

2. Подтягиваем данные таблиц, смотрим строки, проходимся по их значениям (то есть, внутри строки листаем колонки).
Поскольку данные во второй БД нельзя терять, нужна логика сравнения строк в том случае,
когда у них одинаковый PRIMARY KEY - подтягиваются все колонки таблицы. Это повышает нагрузку,
но позволяет сохранить данные. То есть, мы:
- проходимся по каждой строке в таблице
- оцениваем PRIMARY KEY 
- если записи с таким ключом во второй таблице нет, создаем новую
- если она есть во второй таблице, сравниваем значения
- если есть различия, создаем новую запись
- если различий нет, ничего не делаем

В данном алгоритме возможны отличия в зависимости от типа данных. Например, для дат логика возможно будет другая.
Ориентироваться стоит на конкретную ситуацию. Данный алгоритм должен учитывать, что в одной из бд может не оказаться
нужных таблиц. Для этой ситуации нужна отдельная логика, которая также зависит от ситуации. Например, она может
создавать новую таблицу во второй БД при ее отсутствии. Для этого нужно пройтись по всем колонкам первой БД и перенести
их во вторую с учетом всех ее параметров (primary key, nullable, unique, index, default, server default).

Наконец, третий метод, который должен непосредственно синхронизировать БД. 

*  def synchronize_database(self, tables: List[str] = None) -> None:

Данный метод должен принимать список с названиями таблиц для синхронизации.
Если таблицы не указаны, синхронизация проводится для всех таблиц в БД - для этого пишется логика,
выбирающая все таблицы в бд. 
Этот метод не должен ничего возвращать, но это можно изменить при необходимости.
(Например, настроить вывод списка измененных таблиц). С этим методом все просто, он должен:
- проходиться по всем таблицам, которые нужно синхронизировать
- для каждой пары таблиц вызывать метод поиска различий в структуре
- если различия есть, логировать их и не проводить синхронизацию
- если различий нет, вызывать метод synchronize_table()

В целом, этого должно хватить для общего случая.
Конкретные аспекты будут различаться в зависимости от широкого спектра параметров.
